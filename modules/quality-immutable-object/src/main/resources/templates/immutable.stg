import "builder.stg"


immutableClassFile(clazz, copyConstructorAttribute, immutableAnnotation, immutableName, useGuava, builderName, builderNotThreadSafeAnnotation) ::= <<
<package(clazz.package.name)>

<clazz.imports:immutableImport(); separator = "\n">
<immutableAnnotation:immutableImport()>
<if(builderName)><builderNotThreadSafeAnnotation:immutableImport()><endif>

<immutableClass(clazz, copyConstructorAttribute, immutableAnnotation, immutableName, useGuava, builderName, builderNotThreadSafeAnnotation)>
>>


immutableClass(clazz, copyConstructorAttribute, immutableAnnotation, immutableName, useGuava, builderName, builderNotThreadSafeAnnotation) ::= <<
<if(immutableAnnotation)>@<immutableAnnotation.type.name><endif>
<clazz.visibility.name> <clazz.final.name> class <immutableName> implements <clazz.interfaces:interface(); separator = ","> {

	<renderBuilderClass(builderName, clazz, copyConstructorAttribute, builderNotThreadSafeAnnotation, true)>

	<clazz.fields:immutableConstant(); separator = "\n">

	<copyOfMethod(clazz,immutableName,copyConstructorAttribute); separator = "\n">

	<clazz.fields:immutableMemberField(); separator = "\n">

	<constructor(immutableName, clazz.fields, useGuava)>

	<equalsMethod(immutableName, clazz.fields, useGuava)>

	<clazz.fields:renderAccessorMethod(); separator = "\n">

	<hashCodeMethod(clazz.fields, useGuava)>

}
>>


equalsMethod(name, fields, useGuava) ::= <<
@Override
public boolean equals(final Object obj) {
	if (this == obj)
		return true;
	if (obj == null)
		return false;
	if (getClass() != obj.getClass())
		return false;
	<name> other = (<name>) obj;
	<if(useGuava)>
	return <fields:equalsMemberFieldWithOther(); separator = " && ">;
	<else>
	<fields:equalsFieldBlock()>
	return true;
	<endif>
}
>>


equalsFieldBlock(field) ::= <<
<if(field.static.undefined)><if(field.nullable)>
if (<field.name> == null) {
	if (other.<field.name> != null)
		return false;
} else <endif>
if (<if(field.type.primitive)><field.name> != other.<field.name><else>!<field.name>.equals(other.<field.name>)<endif>)
	return false;<endif>
>>


equalsMemberFieldWithOther(field) ::= <<
<if(field.static.undefined)>Objects.equal(this.<field.name>, other.<field.name>)<endif>
>>


hashCodeMethod(fields, useGuava) ::= <<
@Override
public int hashCode() {
	<if(useGuava)>
	return Objects.hashCode(<fields:renderAccessToMemberField(); separator = ",">);
	<else>
	final int prime = 31;
	int result = 1;
	<fields:hashCodeField()>
	return result;
	<endif>
}
>>


hashCodeField(field) ::= <<
<if(field.static.undefined)>
result = prime * result + 
<if(field.type.primitive)><field.name>
<elseif(field.nullable)>(<field.name> == null ? 0 : <field.name>.hashCode())
<else><field.name>.hashCode()
<endif>;<endif>
>>


renderAccessorMethod(field) ::= <<
<if(field.static.undefined)>
<field.annotations:renderAnnotation(); separator = "\n">
public <importedType(field.type)> <field.accessorMethodName>() {
	return <field.name>;
}
<endif>
>>


renderAccessToMemberField(field) ::= <<
<if(field.static.undefined)>this.<field.name><endif>
>>


renderAnnotation(annotation) ::= <<
@<annotation.type.name>
>>


renderAttribute(field) ::= <<
<if(field.static.undefined)><field.annotations:renderAnnotation()> final <importedType(field.type)> <field.name><endif>
>>


constructor(name, fields, useGuava) ::= <<
public <name>(<fields:renderAttribute(); separator = ",">) {
	<setupFields(fields, useGuava)>}
>>


copyOfMethod(clazz, immutableName, attribute) ::= <<
@Nonnull
public static <immutableName> copyOf(@Nonnull final <first(clazz.interfaces):interface()> <attribute.name>) {
	Check.notNull(<attribute.name>, "<attribute.name>");
	return new <immutableName>(<renderCopyOfAttributes(clazz.fields, attribute.name)>);
}
>>


renderCopyOfAttributes(fields, attributeName) ::= <<
<fields:{ f |
	<renderCopyOfAttribute(f, attributeName)>
}; separator = ",">
>>


renderCopyOfAttribute(field, attributeName) ::= <<
<if(field.static.undefined)><attributeName>.<field.accessorMethodName>()<endif>
>>


renderCopyConstructor(name, attribute, fields) ::= <<
<if(attribute)>
public <name>(<attribute.annotations:renderAnnotation(); separator = " "> final <importedType(attribute.type)> <attribute.name>) {
	<fields:{ f | <renderCopyField(f, attribute.name)> }>
}
<endif>
>>


renderCopyField(field, attributeName) ::= <<
<if(field.static.undefined)>this.<field.name> = <attributeName>.<field.accessorMethodName>();<endif>
>>


immutableMemberField(field) ::= <<
<if(field.static.undefined)>
<field.annotations:renderAnnotation(); separator = "\n">
private final <importedType(field.type)> <field.name>;
<endif>
>>


immutableConstant(field) ::= <<
<if(!field.static.undefined)>
<field.annotations:renderAnnotation(); separator = "\n">
<field.visibility.name> static final <importedType(field.type)> <field.name> = <field.value>;
<endif>
>>


immutableImport(i) ::= <<
<if(i)>import <i.type.package.name>.<i.type.name>;<endif>
>>


importedType(type) ::= <<
<type.name>
<if(!type.genericDeclaration.undefined)>
\<<type.genericDeclaration.declaration>\>
<endif>
>>


interface(interface) ::= <<
<interface.type.name>
>>


package(package) ::= <<
<if(package)>package <package>;<endif>
>>


copyTypeBegin(type, useGuava) ::= <<
<if(type.collectionVariant)><if(useGuava)><type.collectionVariant.guava>(<else><type.collectionVariant.unmodifiable>(<endif><endif>
>>


copyTypeEnd(type, useGuava) ::= <<
<if(type.collectionVariant)>)<endif>
>>


setupField(field, useGuava) ::= <<
<if(field.static.undefined)>this.<field.name> = <copyTypeBegin(field.type, useGuava)><if(field.nonnegative)>Check.notNegative(<field.name>,"<field.name>")<elseif(field.nonnull)>Check.notNull(<field.name>,"<field.name>")<else><field.name><endif><copyTypeEnd(field.type, useGuava)>;<endif>
>>


setupFields(fields, useGuava) ::= <<
<fields: { f|
	<setupField(f, useGuava)>
}>
>>
